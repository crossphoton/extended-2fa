const CACHE_NAME = "web"; // TODO: switch to version based
var urlsToCache = new Set();
urlsToCache.add("/index.html");
urlsToCache.add("/index.css");
urlsToCache.add("/icons/logo.png");

// Get generated files list from asset-manifest.json [Again generated by React only].
async function getFilesList() {
  return fetch("./asset-manifest.json").then((res) => res.json());
}

// Install event for new service worker.
self.addEventListener("install", (event) => {
  self.skipWaiting(); // Force new service worker on new code.

  // TODO: Delete from cache whatever is not present now
  // event.waitUntil(
  //   caches.keys().then(function (cacheNames) {
  //     return Promise.all(
  //       cacheNames.map(function (cacheName) {
  //         return caches.delete(cacheName);
  //       })
  //     );
  //   })
  // );

  // Cache everything new
  event.waitUntil(
    caches.open(CACHE_NAME).then(async (cache) => {
      // const list = await getFilesList();
      // if (list)
      //   Object.values(list.files).forEach((val) => urlsToCache.add(val));
      return cache.addAll(urlsToCache);
    })
  );
});

// Listen for requests
self.addEventListener("fetch", (event) => {
  event.respondWith(
    caches.match(event.request).then((cachedResponse) => {
      if (cachedResponse) {
        console.log("Serving from cache: ", event.request.url);
        return cachedResponse;
      }
      return fetch(event.request);
    })
  );
});

// Activate the SW
self.addEventListener("activate", (event) => {
  const cacheWhitelist = [];
  cacheWhitelist.push(CACHE_NAME);
  event.waitUntil(
    caches.keys().then((cacheNames) =>
      Promise.all(
        cacheNames.map((cacheName) => {
          if (!cacheWhitelist.includes(cacheName)) {
            return caches.delete(cacheName);
          }
        })
      )
    )
  );
});
